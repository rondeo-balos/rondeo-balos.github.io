<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Custom 360 Tour with Three.js</title>
    <!--<script src="libs/threejs/build/three.min.js"></script>-->
    
    <script src="https://zeptojs.com/zepto.min.js"></script>
</head>
<body>
    <style>
        #container canvas {
            width: 100% !important;
            height: 100% !important;
            cursor: pointer;
        }
        #container {
            width: 100vw;
            height: 100vh;
        }
        html, body {
            padding: 0;
            margin: 0;
        }
    </style>
    <div id="container"></div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tween.js/23.1.1/tween.umd.min.js" integrity="sha512-vc8qtt+T0keE5z2Iotm/3XGtKhhiR9mR5QgwwJ35IFhFG+EMxNm1KXOeBISBWcmk9g88OQqM8litiBwGFzlrhw==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
    <script type="module">
        import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.135.0/build/three.module.js';

        "use strict";

        console.log( TWEEN );
        var camera,
            scene,
            element = document.getElementById('container'),
            renderer,
            onPointerDownPointerX,
            onPointerDownPointerY,
            onPointerDownLon,
            onPointerDownLat,
            fov = 70,
            isUserInteracting = false,
            lon = 0,
            lat = 0,
            phi = 0,
            theta = 0,
            width = 1440,
            height = 650,
            ratio = width / height;

        var images = {
            pano_1: {
                image: 'images/pano_1.jpg',
                links: [
                    {
                        id: 'pano_2',
                        heading: 0
                    }
                ]
            },
            pano_2: {
                image: 'images/pano_2.jpg',
                links: [
                    {
                        id: 'pano_1',
                        heading: 180
                    },
                    {
                        id: 'pano_3',
                        heading: 0
                    }
                ]
            },
            pano_3: {
                image: 'images/pano_3.jpg',
                links: [
                    {
                        id: 'pano_2',
                        heading: 180
                    },
                    {
                        id: 'pano_4',
                        heading: 0
                    }
                ]
            },
            pano_4: {
                image: 'images/pano_4.jpg',
                links: [
                    {
                        id: 'pano_3',
                        heading: 160
                    },
                    {
                        id: 'pano_5',
                        heading: -20
                    }
                ]
            },
            pano_5: {
                image: 'images/pano_5.jpg',
                links: [
                    {
                        id: 'pano_4',
                        heading: 180
                    }
                ]
            }
        };

        var currentImageId = 'pano_1';
        var texture;

        var raycaster = new THREE.Raycaster();
        var mouse = new THREE.Vector2();
        var arrowGroup = new THREE.Group();
        var outlineGroup = new THREE.Group();

        function createArrow(heading, id) {
            // Define the shape of the chevron
            var shape = new THREE.Shape();

            // Start at the top-left corner
            shape.moveTo(0, 10);

            // Create the chevron shape
            shape.lineTo(-6, 8);
            shape.lineTo(-10, 8);
            shape.lineTo(0, 20);
            shape.lineTo(10, 8);
            shape.lineTo(6, 8);

            // Close the shape
            shape.closePath();

            // Define the geometry by extruding the shape
            var extrudeSettings = {
                steps: 1,
                depth: 1,
                bevelEnabled: false,
            };

            var geometry = new THREE.ExtrudeGeometry(shape, extrudeSettings);
            geometry.rotateX(Math.PI / 2);
            geometry.rotateY(-(Math.PI / 2));

            const material = new THREE.MeshBasicMaterial({ color: 0xf8f8f8 });
            var arrow = new THREE.Mesh(geometry, material);
            arrow.position.y = -40;
            arrow.userData.id = id; // Store the ID for click events
            arrow.userData.originalColor = 0xf8f8f8;

            // Calculate rotation based on heading
            var radians = THREE.MathUtils.degToRad(heading);
            arrow.rotation.y = radians;

            // Create an outline material
            var outlineMaterial = new THREE.LineBasicMaterial({ color: 0x000000 });
            // Create edges geometry for the arrow
            var edges = new THREE.EdgesGeometry(geometry);
            var outline = new THREE.LineSegments(edges, outlineMaterial);
            outline.position.copy(arrow.position); // Set position
            outline.rotation.copy(arrow.rotation); // Set rotation
            outline.scale.multiplyScalar(1); // Scale slightly larger
            outline.userData.originalColor = 0x000000;

            outlineGroup.add(outline); // Add outline to group
            arrowGroup.add(arrow);
        }

        function createLinks() {
            var links = images[currentImageId].links;
            links.forEach(link => {
                var heading = link.heading;
                var id = link.id;
                createArrow( heading, id );
            });
        }

        function onWindowResized(event) {
            renderer.setSize(width, height);
            camera.aspect = width / height;
            camera.updateProjectionMatrix();
        }

        function onDocumentMouseDown(event) {
            event.preventDefault();
            onPointerDownPointerX = event.clientX;
            onPointerDownPointerY = event.clientY;
            onPointerDownLon = lon;
            onPointerDownLat = lat;
            isUserInteracting = true;
            element.addEventListener('mousemove', onDocumentMouseMove, false);
            element.addEventListener('mouseup', onDocumentMouseUp, false);

            // Calculate mouse position
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            // Update the raycaster with the mouse coordinates
            raycaster.setFromCamera(mouse, camera);

            // Check for intersections
            var intersects = raycaster.intersectObjects(scene.children, true);

            if (intersects.length > 0) {
                // Check if the intersected object has userData (ID for click events)
                if (intersects[0].object.userData && intersects[0].object.userData.id) {
                    var id = intersects[0].object.userData.id;
                    changePanorama(id);
                    currentImageId = id;
                }
            }
        }

        var previouslyIntersectedObject = [];
        var clientX, clientY;
        function checkIntersections(event) {
            if( event ) {
                clientX = event.clientX;
                clientY = event.clientY;
            }
            // Calculate mouse position
            mouse.x = (clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(clientY / window.innerHeight) * 2 + 1;

            // Update the raycaster with the mouse coordinates
            raycaster.setFromCamera(mouse, camera);

            // Check for intersections
            var intersects = raycaster.intersectObjects(arrowGroup.children, true);

            // Reset color of all previously intersected objects
            if (previouslyIntersectedObject !== null) {
                previouslyIntersectedObject.forEach(object => {
                    object.material.color.set(object.userData.originalColor); // Set color to white
                });
                previouslyIntersectedObject = null;
            }

            if (intersects.length > 0) {
                // Check if the intersected object has userData (ID for click events)
                if (intersects[0].object.userData && intersects[0].object.userData.id) {
                    // Change color of the intersected object
                    intersects[0].object.material.color.set(0xa5a5a5); // Set color to red
                    
                    // Store the intersected object for resetting later
                    previouslyIntersectedObject = intersects.map(intersect => intersect.object);
                }
            }
        }

        function onDocumentMouseMove(event) {
            lon = (event.clientX - onPointerDownPointerX) * -0.175 + onPointerDownLon;
            lat = (event.clientY - onPointerDownPointerY) * -0.175 + onPointerDownLat;

            if( lat < 10 ) {
                outlineGroup.position.y = ((lat-10)*2);
                arrowGroup.position.y = ((lat-10)*2);
            } else {
                outlineGroup.position.y = 0;
                arrowGroup.position.y = 0;
            }
        }

        function onDocumentMouseUp(event) {
            isUserInteracting = false;
            element.removeEventListener('mousemove', onDocumentMouseMove, false);
            element.removeEventListener('mouseup', onDocumentMouseUp, false);
        }

        function onDocumentMouseWheel(event) {
            if (event.wheelDeltaY) {
                fov -= event.wheelDeltaY * 0.05;
            } else if (event.wheelDelta) {
                fov -= event.wheelDelta * 0.05;
            } else if (event.detail) {
                fov += event.detail * 1.0;
            }
            if (fov < 45 || fov > 90) {
                fov = (fov < 45) ? 45 : 90;
            }
            //camera.projectionMatrix.makePerspective(fov, ratio, 1, 1100);
            camera.fov = fov;
            camera.updateProjectionMatrix();
        }

        function loadTexture(imagePath, callback) {
            var loader = new THREE.TextureLoader();
            loader.load(imagePath, function(texture) {
                callback(texture);
            });
        }

        

        var tweenTransition = null;
        /*var vertexShader = `
            varying vec2 vUv;

            void main() {
                vUv = uv;
                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
            }
        `;
        var fragmentShader = `
            uniform sampler2D texture1;
            uniform sampler2D texture2;
            uniform float progress;

            varying vec2 vUv;

            void main() {
                vec4 texel1 = texture2D(texture1, vUv);
                vec4 texel2 = texture2D(texture2, vUv);
                gl_FragColor = mix(texel1, texel2, progress);
            }
        `;*/

        var vertexShader = `
            varying vec2 vUv;
            
            uniform float progress;

            void main() {
                vUv = uv;

                // Morph the vertices based on the progress
                vec3 newPosition = position;
                newPosition.x += sin(progress * 3.14) * 50.0; // Adjust the factor for the desired effect

                gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);
            }
        `;
        var fragmentShader = `
            uniform sampler2D texture1;
            uniform sampler2D texture2;
            uniform float progress;
            
            varying vec2 vUv;

            void main() {
                vec4 texel1 = texture2D(texture1, vUv);
                vec4 texel2 = texture2D(texture2, vUv);

                // Morph the colors based on the progress
                vec4 morphedColor = mix(texel1, texel2, smoothstep(0.0, 1.0, progress));

                gl_FragColor = morphedColor;
            }
        `;

        var transitionMaterial = new THREE.ShaderMaterial({
            uniforms: {
                texture1: { value: null },
                texture2: { value: null },
                progress: { value: 0.0 }
            },
            vertexShader: vertexShader,
            fragmentShader: fragmentShader,
            transparent: true,
            side: THREE.BackSide
        });
        var transitionObject = new THREE.Mesh(new THREE.SphereGeometry(500, 60, 40), transitionMaterial);

        function init() {
            camera = new THREE.PerspectiveCamera(fov, ratio, 1, 1000);
            scene = new THREE.Scene();
            scene.add( arrowGroup );
            scene.add( outlineGroup );
            
            texture = loadTexture(images[currentImageId].image, function(texture) {
                //var mesh = new THREE.Mesh(new THREE.SphereGeometry(500, 60, 40), new THREE.MeshBasicMaterial({ map: texture, side: THREE.BackSide }));
                //mesh.scale.x = -1;
                //scene.add(mesh);
                texture.mapping = THREE.EquirectangularReflectionMapping;
                scene.background = texture;
                transitionMaterial.uniforms.texture1.value = texture;
            });

            transitionObject.scale.x = -1;
            scene.add(transitionObject);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(width, height);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap; // Optional
            element.appendChild(renderer.domElement);
            element.addEventListener('mousedown', onDocumentMouseDown, false);
            element.addEventListener('mousewheel', onDocumentMouseWheel, false);
            element.addEventListener('DOMMouseScroll', onDocumentMouseWheel, false);
            document.addEventListener( 'mousemove', checkIntersections, false );
            window.addEventListener('resize', onWindowResized, false);
            onWindowResized(null);

            createLinks();
        }
        
        function animate() {
            requestAnimationFrame(animate);
            render();

            TWEEN.update();
            //checkIntersections();
        }

        function render() {
            lat = Math.max(-85, Math.min(85, lat));
            phi = THREE.MathUtils.degToRad(90 - lat);
            theta = THREE.MathUtils.degToRad(lon);
            camera.position.x = 100 * Math.sin(phi) * Math.cos(theta);
            camera.position.y = 100 * Math.cos(phi);
            camera.position.z = 100 * Math.sin(phi) * Math.sin(theta);
            camera.lookAt(scene.position);
            renderer.render(scene, camera);
        }

        function changePanorama( id ) {
                    //scene.children[2].material.map = newTexture;
                    //scene.children[2].material.needsUpdate = true;
                    //scene.background = newTexture;
            if (tweenTransition !== null) {
                tweenTransition.stop();
            }
            outlineGroup.clear();
            arrowGroup.clear();
            var currentTexture = scene.background;
            var newTexture = new Promise( (resolve, reject) => {
                loadTexture(images[id].image, function(newTexture) {
                    newTexture.mapping = THREE.EquirectangularReflectionMapping;
                    resolve( newTexture );
                });

            });
            Promise.all( [currentTexture, newTexture] ).then( ([currentTex, newTex]) => {
                
                var cloneTexture = currentTex.clone();
                cloneTexture.needsUpdate = true;

                transitionMaterial.uniforms.texture1.value = cloneTexture;
                transitionMaterial.uniforms.texture2.value = newTex;

                var progress = { value: 0.0 };
                var tweenTransition = new TWEEN.Tween(progress)
                    .to({ value: 1.0 }, 800) // Transition time in milliseconds
                    .onUpdate(function () {
                        transitionMaterial.uniforms.progress.value = progress.value;
                    })
                    .onComplete(function () {
                        scene.background = newTex;
                        currentTex.dispose(); // Dispose the old texture
                        createLinks();
                    })
                    .start();
            });
        }

        init();
        animate();
    </script>
</body>
</html>
